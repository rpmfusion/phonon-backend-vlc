From 6268ba35692acdb9cfdd062a807f957f499fef2c Mon Sep 17 00:00:00 2001
From: Harald Sitter <sitter@kde.org>
Date: Tue, 21 Jun 2016 15:12:28 +0200
Subject: [PATCH 2/2] give libvlc a prefix, to avoid it preprocessing on
 libvlc_foo lines

i.e. technically we should always have
file header > qt include > vlc include > other include > other pvlc include
but apparently there is a case where this isn't being done so
utils/libvlc.h is included before the actual vlc headers which means by
the time the vlc headers are preprocessed the 'libvlc' macro was already
defined which then caused to it being applied to libvlc_foo_kitten_magic
which naturally resulted in compilation failure.

BUG: 364582
---
 src/backend.cpp       | 6 +++---
 src/devicemanager.cpp | 8 ++++----
 src/effectmanager.cpp | 2 +-
 src/media.cpp         | 2 +-
 src/mediaplayer.cpp   | 2 +-
 src/utils/libvlc.h    | 4 ++--
 6 files changed, 12 insertions(+), 12 deletions(-)

diff --git a/src/backend.cpp b/src/backend.cpp
index b59ad34..a3f6aae 100644
--- a/src/backend.cpp
+++ b/src/backend.cpp
@@ -96,7 +96,7 @@ Backend::Backend(QObject *parent, const QVariantList &)
                         qApp->applicationVersion(),
                         PHONON_VERSION_STR,
                         PHONON_VLC_VERSION);
-            libvlc_set_user_agent(libvlc,
+            libvlc_set_user_agent(pvlc_libvlc,
                                   qApp->applicationName().toUtf8().constData(),
                                   userAgent.toUtf8().constData());
         } else {
@@ -121,7 +121,7 @@ Backend::Backend(QObject *parent, const QVariantList &)
                 // If we failed to get a proper icon name, use the appname instead.
                 icon = qApp->applicationName().toLower();
             }
-            libvlc_set_app_id(libvlc,
+            libvlc_set_app_id(pvlc_libvlc,
                               id.toUtf8().constData(),
                               version.toUtf8().constData(),
                               icon.toUtf8().constData());
@@ -176,7 +176,7 @@ Backend::~Backend()
 
 QObject *Backend::createObject(BackendInterface::Class c, QObject *parent, const QList<QVariant> &args)
 {
-    if (!LibVLC::self || !libvlc)
+    if (!LibVLC::self || !pvlc_libvlc)
         return 0;
 
     switch (c) {
diff --git a/src/devicemanager.cpp b/src/devicemanager.cpp
index 665d075..b3966aa 100644
--- a/src/devicemanager.cpp
+++ b/src/devicemanager.cpp
@@ -203,7 +203,7 @@ void DeviceManager::updateDeviceList()
 {
     QList<DeviceInfo> newDeviceList;
 
-    if (!LibVLC::self || !libvlc)
+    if (!LibVLC::self || !pvlc_libvlc)
         return;
 
     QList<QByteArray> audioOutBackends = vlcAudioOutBackends();
@@ -252,7 +252,7 @@ void DeviceManager::updateDeviceList()
         bool hasDevices = false;
         VLC_FOREACH(audio_output_device,
                     device,
-                    libvlc_audio_output_device_list_get(libvlc, soundSystem),
+                    libvlc_audio_output_device_list_get(pvlc_libvlc, soundSystem),
                     libvlc_audio_output_device_list_release) {
             QString idName = QString::fromUtf8(device->psz_device);
             QString longName = QString::fromUtf8(device->psz_description);
@@ -275,11 +275,11 @@ void DeviceManager::updateDeviceList()
             newDeviceList.append(info);
         }
 #else
-        const int deviceCount = libvlc_audio_output_device_count(libvlc, soundSystem);
+        const int deviceCount = libvlc_audio_output_device_count(pvlc_libvlc, soundSystem);
 
         for (int i = 0; i < deviceCount; i++) {
             VString idName(libvlc_audio_output_device_id(libvlc, soundSystem, i));
-            VString longName(libvlc_audio_output_device_longname(libvlc, soundSystem, i));
+            VString longName(libvlc_audio_output_device_longname(pvlc_libvlc, soundSystem, i));
 
             debug() << "found device" << soundSystem << idName << longName;
 
diff --git a/src/effectmanager.cpp b/src/effectmanager.cpp
index bec3eaa..631af13 100644
--- a/src/effectmanager.cpp
+++ b/src/effectmanager.cpp
@@ -46,7 +46,7 @@ EffectInfo::EffectInfo(const QString &name, const QString &description,
 EffectManager::EffectManager(QObject *parent)
     : QObject(parent)
 {
-    if (!libvlc)
+    if (!pvlc_libvlc)
         return;
 
     updateEffects();
diff --git a/src/media.cpp b/src/media.cpp
index e047893..d27ccf7 100644
--- a/src/media.cpp
+++ b/src/media.cpp
@@ -30,7 +30,7 @@ namespace VLC {
 
 Media::Media(const QByteArray &mrl, QObject *parent) :
     QObject(parent),
-    m_media(libvlc_media_new_location(libvlc, mrl.constData())),
+    m_media(libvlc_media_new_location(pvlc_libvlc, mrl.constData())),
     m_mrl(mrl)
 {
     Q_ASSERT(m_media);
diff --git a/src/mediaplayer.cpp b/src/mediaplayer.cpp
index 691f072..c006310 100644
--- a/src/mediaplayer.cpp
+++ b/src/mediaplayer.cpp
@@ -50,7 +50,7 @@ namespace VLC {
 MediaPlayer::MediaPlayer(QObject *parent)
     : QObject(parent)
     , m_media(0)
-    , m_player(libvlc_media_player_new(libvlc))
+    , m_player(libvlc_media_player_new(pvlc_libvlc))
     , m_doingPausedPlay(false)
     , m_volume(75)
     , m_fadeAmount(1.0f)
diff --git a/src/utils/libvlc.h b/src/utils/libvlc.h
index 6dcc96f..a034afd 100644
--- a/src/utils/libvlc.h
+++ b/src/utils/libvlc.h
@@ -30,7 +30,7 @@ struct libvlc_instance_t;
  * Please note that init() must have been called whenever using this, as no
  * checking of self is conducted (i.e. can be null).
  */
-#define libvlc LibVLC::self->vlc()
+#define pvlc_libvlc LibVLC::self->vlc()
 
 /**
  * Foreach loop macro for VLC descriptions.
@@ -50,7 +50,7 @@ struct libvlc_instance_t;
 
 // This foreach expects only a type and variable because getter and releaser are generic.
 // Also the type is in short form i.e. libvlc_foo_t would be foo.
-#define VLC_FOREACH_LIST(type, variable) VLC_FOREACH(type, variable, libvlc_##type##_list_get(libvlc), libvlc_##type##_list_release)
+#define VLC_FOREACH_LIST(type, variable) VLC_FOREACH(type, variable, libvlc_##type##_list_get(pvlc_libvlc), libvlc_##type##_list_release)
 
 // These foreach expect no type because the type is generic, they do however
 // expect a getter to allow usage with our wrapper classes and since the getter
-- 
2.7.4

